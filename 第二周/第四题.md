# 第二周作业第四题

**4.（必做）**根据上述自己对于 1 和 2 的演示，写一段对于不同 GC 和堆内存的总结，提交到 GitHub。

串行GC：

通过打开：-XX：+ UseSerialGC使用串行GC。串行GC是单线程的GC，在进行垃圾收集时，必须STW，暂停其他所有业务线程。在单核CPU下较实用



并行GC：

在JDK8是默认GC。在年轻代使用“标记-复制”算法，老年代使用“标记-清除-整理”算法。其实并行GC可看做是多CPU并行工作版本的串行GC，因此并行GC不管是在年轻代还是老年代，也都需要STW，使用多个（默认情况是CPU核心数）CPU一起回收垃圾，能加快垃圾处理过程，减少业务线程暂停时间。



CMS GC：

CMS是把整个GC过程分成六个步骤，目的是让部分可以并行操作的步骤跟业务线程共同并行执行，减少整个GC中STW的时间。CMS的六个阶段是：

1.初始标记：需要STW，标记GC root对象，以及root对象直接引用对象

2.并发标记：标记由GC root对象引用链上的对象

3.并发预清理：标记老年区中没有被引用的垃圾对象所在的区域为脏区

4.最终标记：需要STW，因为并发过程中，引用关系时刻在发生变化，因此需要暂停所有业务线程，最终确认哪些是垃圾对象

5.并发清除：并发地回收垃圾对象

6.并发重置：GC回收器重置



G1 GC：

通过打开：-XX：+ UseG1GC使用G1 GC。G1 GC的堆不再分成年轻代和老年代，而是分成一个个小块。同时可以设定每次GC时长，每次GC（STW）超过该时长就结束GC，这样会增加GC频率，但是可以控制每次GC时长。G1 GC会优先处理垃圾较多的内存块，可以设置堆内存大小的上下限，在上限的时候开始回收，到下限的时候结束。